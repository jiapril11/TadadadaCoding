---
title: "가상 메모리"
coverTitle: "Virtual memory"
date: "2024-04-15"
category: "System"
published: true
---

## 연속 메모리 할당

프로그램이 실행될 때 메모리에 필요한 공간을 연속적으로 할당하는 방식

### 스와핑

- 스와핑(swapping): 메모리가 부족한 상황에서 시스템이 추가적인 메모리 공간을 확보하기위해 현재 메모리에 적재되어있는 프로세스의 일부 또는 전체를 보조 저장장치로 옮기는것
- 스왑 영역(swap space): 프로세스들이 옮겨지는 보조 저장장치의 일부 영역
- 스왑 아웃(swap-out): 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인(swap-in): 프로세스가 스왑 영역에서 메모리로 옮겨지는 것

### 메모리 할당

- 최초 적합(first fit): 프로세스가 메모리에 할당될 때, 사용 가능한 메모리 공간 중 가장 먼저 발견된 적합한 공간에 할당
- 최적 적합(best fit): 프로세스를 수용할 수 있는 공간 중에서 가장 작은 공간을 선택하는 것
- 최악 적합(worst fit): 프로세스를 수용할 수 있는 공간 중에서 가장 큰 공간을 선택하는 것

### 외부 단편화(external fragmentation)

메모리에는 충분한 총 공간이 있지만 개별적인 프로세스가 할당될 만큼 충분한 연속된 공간이 없는 상황을 의미

## 페이징(Paging)

- 가상 메모리를 일정한 크기의 블록인 페이지로 나누고, 물리적 메모리를 동일한 크기의 프레임으로 나누는 방식
- 각 프로세스는 페이지로 나뉜 가상 주소 공간을 가지며, 이러한 페이지들은 물리적인 프레임에 매핑되어 메모리에 저장됨
- 페이지 단위로 스왑 아웃/스왑 인이 되는데 페이징 시스템에서는 이를 페이지 아웃/페이지 인이라고 부름

### 페이지 테이블

- 각 프로세스마다 페이지 테이블을 가지고 있음
- 현재 어떤 페이지가 어떤 프레임에 할당되었는지를 알려줌

#### 페이지 테이블 베이스 레지스터(Page Table Base Register, PTBR)

- 프로세스가 실행될 때 해당 프로세스의 페이지 테이블이 저장된 주소를 가리킴
- 가상 주소가 물리적인 주소로 변환될 때, 운영체제나 하드웨어는 PTBR을 사용하여 해당 프로세스의 페이지 테이블을 찾고, 가상 주소에 적절한 물리적 주소를 찾음
- 메모리 접근 시간이 두 배로 늘어남(메모리에 있는 테이블 보기위해 한 번, 프레임에 접근하기 위해 한 번)

#### TLB(Translation Lookaside Buffer)

- 주소 변환 과정에서 사용되는 캐시 메모리
- 가장 최근에 사용된 페이지 번호와 해당 페이지의 물리적인 주소를 저장
- TLB hit: TLB에 원하는 페이지 번호가 존재할 경우
- TLB miss: TLB에 원하는 페이지 번호가 존재하지 않을 경우 메모리 내의 페이지 테이블에 접근해야할 경우

### 페이징에서의 주소 변환

- 페이지 번호(page number)와 변위(offset)로 이루어져 있음
- 페이지 번호: 접근하고자 하는 페이지 번호
- 변위: 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지 알기 위한 정보

### 페이지 테이블 엔트리

- 유효 비트(valid bit): 현재 해당 페이지 접근 가능 여부
- 보호 비트(protection bit): Read(읽기), Write(쓰기), eXecute(실행) 가능 여부
- 참조 비트(reference bit): CPU가 이 페이지에 접근한 적이 있는지 여부
- 수정 비트(modified bit or dirty bit): 해당 페이지에 데이터를 쓴 적이 있는지 수정 여부

## 페이지 교체와 프레임 할당

### 요구 페이징(demand paging)

- 실제로 필요한 페이지가 요청될 때만 해당 페이지를 메모리에 로드
- 페이지 부재(page fault)가 발생할 때 페이지를 로드하는 방식
- 순수 요구 페이징(pure demand paging): 아무런 페이지도 메모리에 적재되지 않은 채 무작정 실행하여 실행에 필요한 페이지가 어느 정도 적재되기 이전까지 페이지 폴트가 계속 발생하는 경우

### 페이지 교체 알고리즘(Page Replacement Algorithm)

- 메모리에 모든 메모리를 저장할 수 없는 상황에서 페이지 폴트가 발생할 때 어떤 페이지를 메모리에서 제거하고 새로운 페이지를 로드할 것인지를 결정
- 페이지 폴트를 최소화하고 적절할 페이지를 교체하여 시스템의 성능을 향상

#### FIFO(First-In First-Out) 페이지 교체 알고리즘

- 가장 먼저 메모리에 적재된 페이지를 교체
- 구현은 간단하지만 페이지 접근 패턴을 고려하지 않기 때문에 페이지 부재와 성능에 영향을 줄 수 있음

#### 최적(Optimal) 페이지 교체 알고리즘

- 가장 나중에 사용될 페이지를 교체
- 최적 알고리즘으로 페이지 부재를 최소화할 수 있지만 미래 페이지 접근 패턴을 알 수 있기때문에 구현이 불가능

#### LRU(Least Recently Used) 페이지 교체 알고리즘

- 가장 오랫동안 사용되지 않은 페이지를 교체
- 최적 알고리즘에 가깝지만 구현이 어려움

### 스래싱

- 빈번한 페이지 교체로 CPU 이용률이 낮아지는 문제
- CPU가 실제 작업을 수행하는 것보다 페이지 교체에 더 많은 시간은 소비

### 프레임 할당

- 스래싱을 방지하고 메모 사용을 최적화하기 위한 역할
- 정적 할당 방식: 균등 할당(equal allocation), 비례 할당(proportional allocation)
- 동적 할당 방식: 작업 집합 모델(working set model), 페이지 폴트 빈도(PFF: Page-Fault Frequency)

출처:
[혼자 공부하는 컴퓨터 구조+운영체제](https://product.kyobobook.co.kr/detail/S000061584886?utm_source=google&utm_medium=cpc&utm_campaign=googleSearch&gad_source=1&gclid=Cj0KCQiAzoeuBhDqARIsAMdH14GeU5OJpwRGzE6DkX9i8xKc7p7iwKsF0GbC_P-pP-GccWSHKRkKmJ4aAtbTEALw_wcB)
